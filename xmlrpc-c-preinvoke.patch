--- xmlrpc-c-0.9.10/src/xmlrpc.h	Thu May 30 14:42:49 2002
+++ xmlrpc-c-0.9.10/src/xmlrpc.h.joe	Thu May 30 14:21:16 2002
@@ -568,6 +568,15 @@ xmlrpc_parse_response (xmlrpc_env *env, 
 **                to the caller, and xmlrpc_DECREF'd.
 */
 
+/* A function to call before invoking a method for doing things like access
+** control or sanity checks.  If a fault is set from this function, the
+** method will not be called and the fault will be returned. */
+typedef void
+(*xmlrpc_preinvoke_method) (xmlrpc_env *env,
+			    char *method_name,
+			    xmlrpc_value *param_array,
+			    void *user_data);
+
 /* An ordinary method. */
 typedef xmlrpc_value *
 (*xmlrpc_method) (xmlrpc_env *env,
@@ -593,6 +602,7 @@ typedef struct _xmlrpc_registry {
     int _introspection_enabled;
     xmlrpc_value *_methods;
     xmlrpc_value *_default_method;
+    xmlrpc_value *_preinvoke_method;
 } xmlrpc_registry;
 
 #endif /* XMLRPC_WANT_INTERNAL_DECLARATIONS */
@@ -670,6 +680,17 @@ xmlrpc_registry_set_default_method (xmlr
 				    xmlrpc_default_method handler,
 				    void *user_data);
 
+/* Define a preinvoke method for the specified registry.  This function will
+** be called before any method (either the default or a registered one) is
+** invoked.  Applications can use this to do things like access control or
+** sanity checks.  The user_data pointer is property of the application,
+** and will not be freed or manipulated by the registry. */
+extern void
+xmlrpc_registry_set_preinvoke_method (xmlrpc_env *env,
+				      xmlrpc_registry *registry,
+				      xmlrpc_preinvoke_method method,
+				      void *user_data);
+
 				    
 /*=========================================================================
 **  XML-RPC Base64 Utilities
--- xmlrpc-c-0.9.10/src/xmlrpc_registry.c	Thu May 30 14:42:55 2002
+++ xmlrpc-c-0.9.10/src/xmlrpc_registry.c.joe	Thu May 30 14:33:59 2002
@@ -73,6 +73,7 @@ xmlrpc_registry *xmlrpc_registry_new (xm
     registry->_introspection_enabled = 1;
     registry->_methods = methods;
     registry->_default_method = NULL;
+    registry->_preinvoke_method = NULL;
     registry_valid = 1;
 
     /* Install our system methods. */
@@ -103,6 +104,8 @@ void xmlrpc_registry_free (xmlrpc_regist
     registry->_methods = XMLRPC_BAD_POINTER;
     if (registry->_default_method != NULL)
 	xmlrpc_DECREF(registry->_default_method);
+    if (registry->_preinvoke_method != NULL)
+        xmlrpc_DECREF(registry->_preinvoke_method);
     free(registry);
 }
 
@@ -208,6 +211,42 @@ void xmlrpc_registry_set_default_method 
     }
 }
 
+/*=========================================================================
+**  xmlrpc_registry_set_preinvoke_method
+**=========================================================================
+**  See xmlrpc.h for more documentation.
+*/
+
+void xmlrpc_registry_set_preinvoke_method (xmlrpc_env *env,
+					   xmlrpc_registry *registry,
+					   xmlrpc_preinvoke_method handler,
+					   void *user_data)
+{
+    xmlrpc_value *method_info;
+
+    XMLRPC_ASSERT_ENV_OK(env);
+    XMLRPC_ASSERT_PTR_OK(registry);
+    XMLRPC_ASSERT_PTR_OK(handler);
+
+    /* Error-handling preconditions. */
+    method_info = NULL;
+
+    /* Store our method and user data into our hash table. */
+    method_info = xmlrpc_build_value(env, "(pp)", (void*) handler, user_data);
+    XMLRPC_FAIL_IF_FAULT(env);
+
+    /* Dispose of any pre-existing preinvoke method and install ours. */
+    if (registry->_preinvoke_method)
+	xmlrpc_DECREF(registry->_preinvoke_method);
+    registry->_preinvoke_method = method_info;
+
+ cleanup:
+    if (env->fault_occurred) {
+	if (method_info)
+	    xmlrpc_DECREF(method_info);
+    }
+}
+
 
 /*=========================================================================
 **  dispatch_call
@@ -222,12 +261,23 @@ dispatch_call(xmlrpc_env *env, xmlrpc_re
 {
     xmlrpc_value *method_info, *result;
     void *method_ptr, *user_data;
+    xmlrpc_preinvoke_method preinvoke_method;
     xmlrpc_method method;
     xmlrpc_default_method default_method;
 
     /* Error-handling preconditions. */
     result = NULL;
 
+    /* Get the preinvoke method, if it is set. */
+    if (registry->_preinvoke_method != NULL) {
+        xmlrpc_parse_value(env, registry->_preinvoke_method, "(pp)",
+			   &method_ptr, &user_data);
+        XMLRPC_FAIL_IF_FAULT(env);
+	preinvoke_method = (xmlrpc_preinvoke_method) method_ptr;
+    } else {
+	preinvoke_method = NULL;
+    }
+
     /* Look up the method info for the specified method. */
     method_info = xmlrpc_struct_get_value(env, registry->_methods,
 					  method_name);
@@ -238,6 +288,13 @@ dispatch_call(xmlrpc_env *env, xmlrpc_re
 	    xmlrpc_env_clean(env);
 	    xmlrpc_env_init(env);
 
+	    /* Call our preinvoke method, if it's set */
+	    if (preinvoke_method) {
+		    (*preinvoke_method)(env, method_name,
+					param_array, user_data);
+		    XMLRPC_FAIL_IF_FAULT(env);
+	    }
+
 	    /* Get our default method. */
 	    xmlrpc_parse_value(env, registry->_default_method, "(pp)",
 			       &method_ptr, &user_data);
@@ -254,6 +311,12 @@ dispatch_call(xmlrpc_env *env, xmlrpc_re
 			 "Method %s not defined", method_name);
 	}
     } else {
+	/* Call our preinvoke method, if it's set */
+	if (preinvoke_method) {
+		(*preinvoke_method)(env, method_name,
+				    param_array, user_data);
+		XMLRPC_FAIL_IF_FAULT(env);
+	}
 
 	/* Extract our method information for the matching method. */
 	xmlrpc_parse_value(env, method_info, "(pp*)", &method_ptr, &user_data);
